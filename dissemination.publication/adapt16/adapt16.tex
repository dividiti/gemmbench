% http://www.acm.org/sigs/publications/proceedings-templates
\documentclass{acm_proc_article-sp} % Tested with v3.2SP (April 2009)

\usepackage[hyphens]{url}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{rotating}

\begin{document}

\title{{GEMMbench}: a framework for reproducible and collaborative benchmarking
of matrix multiplication}
%
\subtitle{\LARGE \url{https://github.com/dividiti/gemmbench}}

\numberofauthors{1}
\author{
\alignauthor
  Anton Lokhmotov, {\Large \tt dividiti}\\
  \email{\Large \url{anton@dividiti.com}}\\
  \affaddr{ideaSpace West}\\
  \affaddr{3 Charles Babbage Road}\\
  \affaddr{Cambridge, CB3 0GT}\\
  \affaddr{United Kingdom}\\
}

\maketitle

\begin{abstract}

The generic matrix-matrix multiplication (GEMM) is arguably the most popular
computational kernel of the 20th century.
%
Yet, surprisingly, no common methodology for evaluating GEMM performance
has been established over the many decades of using GEMM for comparing
architectures, compilers and ninja-class programmers.

We introduce GEMMbench, a framework and methodology for evaluating performance
of GEMM implementations.
%
GEMMbench is implemented on top of Collective Knowledge (CK), a lightweight
framework for reproducible and collaborative R\&D in computer systems.
%
Using CK allows the R\&D community to crowdsource hand-written and
compiler-generated GEMM implementations and to study their performance across
multiple platforms, data sizes and data types.
%
Our initial implementation supports hand-written OpenCL kernels operating on
matrices consisting of single- and double-precision floating-point values, and
producing single or multiple output elements per work-item (via thread
coarsening and vectorization).


\end{abstract}

% A category with the (minimum) three required fields
% \category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
% \category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

\terms{Software}

%\keywords{ACM proceedings, \LaTeX, text tagging}



%==============================================================================
\section{Introduction}
%==============================================================================

The generic matrix-matrix multiplication (GEMM) is given by the equation:
%
\begin{displaymath} C = \alpha A \times B + \beta C \end{displaymath}
%
\noindent where $A$, $B$ and $C$ are matrices, and $\alpha$ and $\beta$ are
scalars.

GEMM is arguably the most popular computational kernel of the 20th century.
%
The apparent simplicity of GEMM has haunted generation after generation of
researchers who have evaluated its performance on generation after generation
of computer systems,\footnote{Conveniently, both for researchers and computer
systems a generation means 3--4 years.} while uncovering layer after layer of
its hidden complexity.
%
For example, discovering the beneficial effects of cache blocking on GEMM
performance~\cite{Lam:1991} has fuelled research on locality optimizations in
compilers for many years.

%
Yet, surprisingly, no common methodology for evaluating GEMM performance has
been established over the many decades of using this kernel for comparing
architectures, compilers and ninja-class programmers.
%
Consequently, the reader of a report presenting GEMM results is often left wondering:

\begin{itemize}
%
\item Was the kernel specialized, for example, to $C = A \times B$? (In other
words, $\alpha=1$ and $\beta=0$.)
%
\item Which of the data types were used: single precision (SGEMM), double
precision (DGEMM), complex single precision (CGEMM), or complex double
precision (ZGEMM)?
%
\item Which data layouts were used: normal (N) or transposed (T)?\footnote{For
matrices stored in row-major order, $C = \alpha A \times B^{T} + \beta C$
typically results in better locality, because $B^{T}$ is read row-wise.} If
transposed, did the execution time include the overhead for transposition?
%
\item Which data shapes were used: square or rectangular? If rectangular, did
the execution time depend on the ratio between the dimensions?
%
\item Which data sizes were used: small or large?
%
\item On a system with caches, did `large' result in cache thrashing; did
`small' result in good locality (no thrashing)?
%
\item On a heterogeneous system equipped with a discrete accelerator, did the
execution time include the overhead for copying the data to the accelerator and
back, or only the kernel execution time?
%
\item Did the evaluation include power or energy measurements?
%
\item If a diesel generator was used to get the system running, how many
megaflops per gallon were they
getting?\footnote{\url{http://www.hpcwire.com/2006/06/30/the_new_limits_on_high_performance_computing-1/}}
%
\item More seriously, have we achieved significant improvements in energy
efficiency of floating-point operations over the last
decade?\footnote{Manufactured in 2005 on a 130 nm process, ClearSpeed's CSX600
processor provided 25 DGEMM Gflops/s in under 10 Watts.}
%
\item How much human effort and ingenuity was involved in writing the kernel or
in implementing the compiler that generated the kernel?
%
\item Can we compare the generators, for example, based on polyhedral
compilation~\cite{Beaugnon:2014} and functional expression
rewriting~\cite{Steuwer:2015} in a fair way (including code quality, code
generation time and robustness)?
%
\item Can we evaluate the generators against ninja-class
programmers~\cite{Goto:2008} or vendor libraries?
%
\item Have we used all the tricks up our sleeves to get the fastest GEMM
implementation for our hardware and problem at hand?
%
\item Can we {\em adapt} our GEMM implementations to work well across a range
of architectures, data types, data sizes, etc.?
%
\end{itemize}

Given that are discussing something apparently as simple as GEMM, intended to
give us insights for solving more complex `real-world' problems, it is
essential to start getting some of the answers right to facilitate our learning
and knowledge sharing.

We introduce GEMMbench, a framework and methodology for evaluating performance
of GEMM implementations.
%
GEMMbench is implemented on top of Collective Knowledge (CK), a lightweight
framework for reproducible and collaborative R\&D in computer systems.%
\footnote{\url{http://cknowledge.org}}
%
Our initial implementation supports hand-written OpenCL kernels operating on
matrices consisting of single- and double-precision floating-point values, and
producing single or multiple output elements per work-item (via thread
coarsening and vectorization).
%
Over time, we plan to involve the community to add further hand-written and
generated kernels (e.g. from \cite{Beaugnon:2014,Steuwer:2015}), and,
importantly, to collectively study the GEMM performance across multiple
platforms, data sizes and data types.


%==============================================================================
\section{Implementation details}
\label{sec:details}
%==============================================================================

%
The GEMMbench framework reads from a JSON file the metadata describing a
kernel.
%
The JSON file specifies the data type ({\tt S} or {\tt D}), the layout of the
matrices ({\tt N} or {\tt T}), the thread-coarsening configuration ({\tt di}
for the number of rows and {\tt dj} for the number of columns in a block
computed by a single work-item), and so on.

For example, the SGEMM kernel that assumes that $A$ is non-transposed and $B$
is transposed and outputs a single element per work-item:
%
\begin{verbatim}
kernel void gemm(
    global float const * restrict A,
    global float const * restrict B,
    global float       * restrict C,
    float alpha, float beta, uint n)
{
    const uint j = get_global_id(0);
    const uint i = get_global_id(1);

    float ABij = 0.0f;
    for (uint k = 0; k < n; k += 1)
    {
        ABij += A[i*n + k] * B[j*n + k];
    }
    C[i*n + j] = alpha * ABij + beta * C[i*n + j];
}
\end{verbatim}
%
is described by the following metadata:
%
\begin{verbatim}
{
    "name"   : "SGEMM_NT_1x1",
    "file"   : "SGEMM_NT_1x1.cl",
    "type"   : "S",
    "transA" : "N",
    "transB" : "T",
    "dj"     : 1,
    "di"     : 1
}
\end{verbatim}

See further examples in the {\tt dataset} entries of the GEMMbench repository.%
\footnote{\url{https://github.com/dividiti/gemmbench/tree/master/dataset}}


%==============================================================================
\section{How to reproduce?}
%==============================================================================

Briefly, install Collective Knowledge\footnote{\url{http://github.com/ctuning/ck}}
and follow the steps:
%
\begin{verbatim}
$ ck pull repo:gemmbench \
    --url=https://github.com/dividiti/gemmbench
$ cd `ck find repo:gemmbench`
$ ck compile
$ ck run
\end{verbatim}
%
More information will appear on the GEMMbench page during the period of public discussions.


%==============================================================================
\section{Experimental evaluation}
%==============================================================================

We demonstrate using the GEMMbench framework for evaluating 3 SGEMM NT
OpenCL kernels on a Hardkernel Odroid~XU3 board (Table~\ref{Odroid}).%
\footnote{\url{http://www.hardkernel.com/main/products/prdt_info.php?g_code=G140448267127}}

%------------------------------------------------------------------------------
\subsection{Evaluation platform}
%------------------------------------------------------------------------------

The Odroid XU3 board has 4 integrated power consumption sensors:
%
\begin{itemize}

  \item for the LPDDR3 RAM;

  \item for the CPU cluster 0 comprised of 4 ARM Cortex-A7 (``LITTLE'') cores;

  \item for the CPU cluster 1 comprised of 4 ARM Cortex-A15 (``big'') cores;

  \item for both the GPU cluster 0 and the GPU cluster 1 comprised respectively
  of 4 and 2 ARM Mali-T628 cores.

\end{itemize}
%
We reused the {\em pipeline} functionality of the underlying Collective
Knowledge framework to conduct experiments under controlled conditions.
%
We ran the SGEMM kernels on the GPU cluster 0 (OpenCL device 0); we disabled
dynamic voltage and frequency scaling (DVFS) and set the frequency to the
maximum of 600 MHz.
%
Likewise, we set the CPU governors to the performance mode and the CPU
frequencies to the maximum.
%

%------------------------------------------------------------------------------
\subsection{OpenCL kernels}
%------------------------------------------------------------------------------

The SGEMM NT kernels are contained in 3 separate files:
%
\begin{itemize}

  \item \verb|SGEMM_NT_1x1.cl|: a na\"ive version shown in
  Section~\ref{sec:details} which computes a single element of matrix $C$ per
  work-item;

  \item \verb|SGEMM_NT_4x1.cl|: a vectorised version which computes a vector of
  four adjacent elements of matrix $C$ per work-item;

  \item \verb|SGEMM_NT_4x1_barrier.cl|: a similarly vectorised version which
  synchronises work-items in a work-group with a barrier to improve cache
  utilisation~\cite{Gronqvist:2014}.\footnote{\url{http://malideveloper.arm.com/downloads/GPU_Pro_5/GronqvistLokhmotov_white_paper.pdf}}

\end{itemize}
%

\begin{table*}
\centering
\caption{\label{Odroid}Experimental platform: Hardkernel Odroid~XU3 board.}
  \begin{tabular}{ll}
  \toprule
  {\bf Hardware}   &\\
  \midrule
  System-on-chip (SoC)         & Samsung Exynos 5422                     \\
  GPU cluster 0 (``device 0'') & ARM Mali-T628,  4 cores, $\le$ 600 MHz  \\
  GPU cluster 1 (``device 1'') & ARM Mali-T628,  2 cores, $\le$ 600 MHz  \\
  CPU cluster 0 (``LITTLE'')   & ARM Cortex-A7,  4 cores, $\le$ 1400 MHz \\
  CPU cluster 1 (``big'')      & ARM Cortex-A15, 4 cores, $\le$ 2000 MHz \\
  LPDDR3 RAM                   & 2 GiB, $\le$ 14.9 Gbytes/s              \\
  \midrule
  {\bf Software}   &\\
  \midrule
  Board support package (BSP)  & 2015-02-25                    \\
  Ubuntu Linux                 & 14.04.1 (updated to 14.04.3)  \\
  Linux kernel                 & 3.10.69                       \\
  OpenCL version               & 1.1 Full Profile              \\
  OpenCL driver                & 4.0 (BSP default)             \\
  Host compiler                & Clang++ 3.6                   \\
  \bottomrule
  \end{tabular}
\end{table*}


%------------------------------------------------------------------------------
\subsection{Varying the matrix order}
%------------------------------------------------------------------------------

% For the first set of experiments...

In our evaluation, we varied the matrix order from 64 to 1024,
{\em i.e.}\ performed experiments for the matrix dimensions ranging from $64
\times 64$ to $1024 \times 1024$.
%
We fixed the OpenCL local work size (work-group size) to $(8,8)$, which,
depending on the register usage, supports up to four concurrently executing
work-groups per Mali-T628 core~\cite{Gronqvist:2014}.

Columns 0--3 of Table~\ref{SGEMM_NT:df} shows the raw results in
Gflops/s from 4 statistical repetitions (under the same experimental
conditions); column 4 shows the mean for each experiment (computed using {\tt
pandas.mean()}); column 5 shows the standard deviation (computed using {\tt
pandas.std()}).
%
Figure~\ref{SGEMM_NT:plot} shows the means as a bar plot with the error bars
taken from the standard deviations.

Across the matrix orders, the program in \verb|SGEMM_NT_1x1.cl| achieved
low but stable performance up to 3 Gflops/s.
%
The program in \verb|SGEMM_NT_4x1.cl| achieved up to 12 Gflops/s but its
performance dropped dramatically for the matrix orders that were a multiple of
256: 256, 512, 768 and 1024.
%
In addition, it exhibited high performance variation for the matrix orders of
256 and 896.
%
The program in \verb|SGEMM_NT_4x1_barrier.cl| achieved up to 11.5
Gflops/s. Importantly, it maintained high performance of 9--10 Gflops/s
for the matrix orders above 256.


\begin{table*}
  \centering
  \caption{\label{SGEMM_NT:df}The performance of 3 SGEMM NT kernels: {\tt pandas} DataFrame with raw results.}
  \input{SGEMM_NT-explore-f-n_tmp.tex}
\end{table*}

\begin{figure*}
  \includegraphics[width=\textwidth]{SGEMM_NT-explore-f-n_tmp.pdf}
  \caption{The performance of 3 SGEMM NT kernels: {\tt matplotlib} bar plot with error bars.}
  \label{SGEMM_NT:plot}
\end{figure*}


%------------------------------------------------------------------------------
%\subsection{Varying the local work size}
%------------------------------------------------------------------------------
%
%For the second set of experiments, we varied the local work size (work-group
%size) for the \verb|SGEMM_NT_4x1_barrier.cl| program and four values of the
%matrix order.
%%

%\begin{figure*}
%  \includegraphics[width=\textwidth]{SGEMM_NT-explore-n-lws_tmp.pdf}
%  \caption{The performance of 3 SGEMM NT kernels: {\tt matplotlib} bar plot with error bars.}
%  \label{SGEMM_NT:plot}
%\end{figure*}

%-------------------------------------------------------------------------------
\subsection{Comparing energy consumption}
%-------------------------------------------------------------------------------

Using the integrated sensors on the Odroid XU3 board, we estimated energy
consumption for the program region that launches a kernel and waits for its
completion.\footnote{We used a rather crude method of averaging the power
consumption measurements at the start and end of the region and multiplying the
average by the execution time.}

Table~\ref{SGEMM_NT:df:energy} shows the estimated GPU and memory energy
consumption in Joules across the 3 kernels and 11 matrix orders.
%
Figure~\ref{SGEMM_NT:plot:energy} focusses on the energy consumption for the
orders from 384 to 1024.

For the orders of 128 and 384, when the vectorised kernels match in
performance, they also match in energy consumption.
%
For the order of 1024, however, the non-cache optimised kernel is a disaster:
%
the cache-optimised vectorised kernel is $6$ times faster and $40$ times more
energy efficient both for the GPU and the RAM;
%
even the non-vectorised kernel is $75\%$ faster, $10\%$ more energy efficient
for the GPU and $5$ times for the RAM.

\begin{table*}
  \centering
  \caption{\label{SGEMM_NT:df:energy}The GPU \& memory energy consumption of 3 SGEMM NT kernels: {\tt pandas} DataFrame with raw results.}
  \input{SGEMM_NT-explore-f-n-energy-gpu-mem_tmp.tex}
\end{table*}

\begin{figure*}
  \includegraphics[width=\textwidth]{SGEMM_NT-explore-f-n-energy-gpu-mem_tmp.pdf}
  \caption{The GPU \& memory energy consumption of 3 SGEMM NT kernels: {\tt matplotlib} bar plot.}
  \label{SGEMM_NT:plot:energy}
\end{figure*}


%-------------------------------------------------------------------------------
\subsection{Validating the results}
%-------------------------------------------------------------------------------

Table~\ref{SGEMM_NT:df:match}.

\begin{sidewaystable*}
  \centering
  \caption{\label{SGEMM_NT:df:match}The validation of 3 SGEMM NT kernels: {\tt pandas} DataFrame with raw results.}
  \input{SGEMM_NT-explore-f-n-match_tmp.tex}
\end{sidewaystable*}

%\subsection{Varying the local work size}
%
%For the second set of experiments, we varied the local work size (work-group
%size) for the \verb|SGEMM_NT_4x1_barrier.cl| program and four values of the
%matrix order.
%%

%\begin{figure*}
%\includegraphics[width=\textwidth]{SGEMM_NT-explore-n-lws_tmp.pdf}
%\caption{The performance of 3 SGEMM NT kernels: {\tt matplotlib} bar plot with error bars.}
%\label{SGEMM_NT:plot}
%\end{figure*}


%===============================================================================
\section{Conclusion and outlook}
%===============================================================================

We have presented GEMMbench, a framework and methodology for systematically
evaluating performance of matrix multiplication implementations.
%
Our initial implementation supports hand-written OpenCL kernels, producing
single or multiple output elements per work-item (via thread coarsening and
vectorization).
%

Our goal is to involve the community to extend GEMMbench to evaluate
performance of compiler-generated OpenCL kernels, non-OpenCL implementations,
library implementations and so on, across many target platforms.
%
To this end, the underlying Collective Knowledge framework provides unique
opportunities for the community to gradually gather and share valuable
knowledge for optimizing performance of matrix multiplication and other
programs, as well as of compilers and processors.
%
We will build upon other strengths of the Collective Knowledge framework such
as support for multiple operating systems (Windows, Linux, Android and MacOS),
compilers (LLVM, GCC, ICC, MSVC, {\em etc.}) and interfaces to packages for
data mining and predictive analytics.

%===============================================================================
\section*{Acknowledgments and more}
%===============================================================================

We thank Grigori Fursin, CTO of {\tt dividiti} and Chief Scientist of the
cTuning foundation, for designing and implementing the Collective
Knowledge framework, on top of which we implemented GEMMbench.

We look forward to the public discussion of this article and hope to get
useful feedback and contributions from the community.

%-------------------------------------------------------------------------------

\bibliographystyle{abbrv}
\bibliography{adapt16}

\balancecolumns

\end{document}
